using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Threading.Tasks;
using Core;
using Manager.Models.Movie;
using Manager.Services.Configuration;
using Services;

namespace Manager.Services
{
	public class MovieService
	{
		private readonly MovieConfiguration _config;
		/// <summary>
		/// Tick when the user's cfg will be loaded.
		/// </summary>
		private const int EXEC_USER_CFG_TICK = 50;
		/// <summary>
		/// Tick when required commands will be executed.
		/// </summary>
		private const int EXEC_COMMANDS_TICK = EXEC_USER_CFG_TICK + 64;
		/// <summary>
		/// Tick that will fast forward to the tick where recording must start
		/// </summary>
		private const int GOTO_TICK = EXEC_COMMANDS_TICK + 64;
		/// <summary>
		/// VDM files needs a double \ to escape the path
		/// </summary>
		private string RawFullPath => _config.RawFilesDestination.Replace("\\", "\\\\") + "\\\\" + _config.OutputFilename;

		public event Action OnVirtualDubStarted;
		public event Action OnVirtualDubClosed;
		public event Action OnFFmpegStarted;
		public event Action OnFFmpegClosed;
		public event Action OnGameStarted;
		public event Action OnGameRunning;
		public event Action OnGameClosed;
		public event Action OnHLAEStarted;
		public event Action OnHLAEClosed;

		public MovieService(MovieConfiguration config)
		{
			_config = config;
		}

		public static readonly List<string> DefaultCommands = new List<string>
		{
			"cl_draw_only_deathnotices 1",
			"cl_clock_correction 0",
			"mirv_fix playerAnimState 1",
			"mirv_streams record matPostprocessEnable 1",
			"mirv_streams record matDynamicTonemapping 1",
			"mirv_streams record matMotionBlurEnabled 0",
			"mirv_streams record matForceTonemapScale 0",
			"net_graph 0",
		};

		/// <summary>
		/// The following commands are required to have a working recording.
		/// </summary>
		public static readonly List<string> MandatoryCommands = new List<string>
		{
			"sv_cheats 1",
			"host_timescale 0",
			"mirv_snd_timescale 1", // fix the audio sync issue with startmovie command
			"mirv_gameoverlay enable 1",
		};

		public async Task Start()
		{
			if (_config.GenerateRawFiles)
			{
				GenerateCfgFile();
				GenerateVdmFile();
				GameLauncherConfiguration config = new GameLauncherConfiguration(_config.Demo)
				{
					EnableHlae = true,
					OnGameStarted = HandleGameStarted,
					OnGameRunning = HandleGameRunning,
					OnGameClosed = HandleGameClosed,
					OnHLAEStarted = HandleHLAEStarted,
					OnHLAEClosed = HandleHLAEClosed,
					DeleteVdmFileAtStratup = false,
					CsgoExePath = AppSettings.GetCsgoExePath(), // TODO move it?
					EnableHlaeConfigParent = _config.EnableHlaeConfigParent,
					Fullscreen = false,
					Height = _config.Height,
					Width = _config.Width,
					HlaeConfigParentFolderPath = _config.HlaeConfigParentFolderPath,
					HlaeExePath = HlaeService.GetHlaeExePath(),
					LaunchParameters = _config.LaunchParameters,
					SteamExePath = AppSettings.SteamExePath(), // TODO move it?
				};

				GameLauncher launcher = new GameLauncher(config);
				await launcher.StartGame();
			}
			else
			{
				// just simulate that the game has been closed to start encoding
				await HandleGameClosed();
			}
		}

		/// <summary>
		/// Return FFmpeg CLI arguments based on the current configuration as a string.
		/// </summary>
		/// <returns></returns>
		public string GetFFmpegCommandLineAsString()
		{
			string command = string.Empty;
			if (FFmpegService.IsFFmpegInstalled())
			{
				command += FFmpegService.GetFFmpegExePath();
				List<string> args = GetFFmpegArgs();
				command += " " + String.Join(" ", args.ToArray());
			}

			return command;
		}

		/// <summary>
		/// Return true if the first tga file generated by the game for the current configuration exists.
		/// </summary>
		/// <returns></returns>
		public bool IsFirstTgaExists()
		{
			return File.Exists(GetFirstTgaPath());
		}

		/// <summary>
		/// Delete all TGA files.
		/// </summary>
		public void DeleteTgaFiles()
		{
			string tga = _config.OutputFilename + "*.tga";
			string[] files = Directory.GetFiles(_config.RawFilesDestination, tga);
			foreach (string file in files) File.Delete(file);
		}

		/// <summary>
		/// Kill all processes.
		/// </summary>
		public void Cancel()
		{
			string[] names = { "csgo", "HLAE", "ffmpeg", "Veedub64", "VirtualDub" };
			foreach (string name in names)
				KillProcess(name);
		}

		/// <summary>
		/// Return the path to the first TGA created by the game.
		/// </summary>
		/// <returns></returns>
		private string GetFirstTgaPath()
		{
			return RawFullPath + "0000.tga";
		}

		/// <summary>
		/// Return the path where the WAV file will be created.
		/// </summary>
		/// <returns></returns>
		private string GetWavFilePath()
		{
			return RawFullPath + ".wav";
		}

		/// <summary>
		/// Return the path where the video will be saved.
		/// </summary>
		/// <returns></returns>
		private string GetOuputFilePath()
		{
			string extension = _config.UseVirtualDub ? ".avi" : ".mp4";
			return _config.OutputFileDestinationFolder + Path.DirectorySeparatorChar + _config.OutputFilename + extension;
		}

		/// <summary>
		/// Create a CFG file which will be loaded when the demo start.
		/// Users can edit it from the UI.
		/// </summary>
		private void GenerateCfgFile()
		{
			string cfgPath = GetCfgPath();
			File.WriteAllText(cfgPath, string.Join(Environment.NewLine, _config.UserCfg));
		}

		/// <summary>
		/// Return the path to the CFG which will be execute when the demo start.
		/// </summary>
		/// <returns></returns>
		private static string GetCfgPath()
		{
			string csgoPath = AppSettings.GetCsgoPath();
			if (string.IsNullOrEmpty(csgoPath))
				throw new Exception("Unable to find csgo folder.");
			string cfgPath = csgoPath + Path.DirectorySeparatorChar + "cfg";
			if (!Directory.Exists(cfgPath))
				throw new Exception("Unable to find a cfg folder within the csgo folder.");

			return cfgPath + Path.DirectorySeparatorChar + "csgodm_movie.cfg";
		}

		/// <summary>
		/// Generate the VirtualDub jobs file.
		/// </summary>
		private void GenerateVirtualDubScript()
		{
			string[] tgaFiles = Directory.GetFiles(_config.RawFilesDestination, _config.Demo.NameWithoutExtension + "*.tga");
			string videoPath = GetOuputFilePath().Replace("\\", "\\\\");
			string firstTgaFilePath = GetFirstTgaPath();
			string wavFilePath = RawFullPath + ".wav";
			string vdScript = string.Format(Properties.Resources.vd, firstTgaFilePath, wavFilePath, _config.FrameRate, tgaFiles.Length, videoPath);
			string virtualDubPath = VirtualDubService.GetVirtualDubPath();
			if (Directory.Exists(virtualDubPath))
				File.WriteAllText(virtualDubPath + Path.DirectorySeparatorChar + "csgodm.jobs", vdScript);
		}

		/// <summary>
		/// Generate the VDM file.
		/// </summary>
		private void GenerateVdmFile()
		{
			int actionCount = 0;

			string generated = string.Empty;

			// Step 1, execute the user's cfg / cvars
			generated += string.Format(Properties.Resources.execute_command, ++actionCount, EXEC_USER_CFG_TICK, "exec csgodm_movie.cfg");

			// Step 2, add explicitly mandatory cvars with a small delay to be sure user's cfg has been loaded
			foreach (string command in MandatoryCommands)
				generated += string.Format(Properties.Resources.execute_command, ++actionCount, EXEC_COMMANDS_TICK, command);

			// Step 3, execute required commands with dynamic args
			generated += string.Format(Properties.Resources.execute_command, ++actionCount, EXEC_COMMANDS_TICK, "host_framerate " + _config.FrameRate);
			generated += string.Format(Properties.Resources.execute_command, ++actionCount, EXEC_COMMANDS_TICK, "mirv_streams record name \\\"" + RawFullPath + "\\\"");

			// Step 4, go to some ticks just before to start recording to be sure that the world has been fully loaded
			int goToTick = _config.StartTick < 256 ? 1 : _config.StartTick - 256;
			generated += string.Format(Properties.Resources.skip_ahead, ++actionCount, GOTO_TICK, goToTick);

			// step 5, focus on player if a SteamID has been provided
			if (_config.FocusSteamId != 0)
				generated += string.Format(Properties.Resources.spec_player, ++actionCount, GOTO_TICK + 1, _config.FocusSteamId);

			// Step 6, start recording !!escaping quotes is required for vdm files!!
			string startCommand = "mirv_streams record start; startmovie \\\"" + RawFullPath + "\\\"";
			generated += string.Format(Properties.Resources.execute_command, ++actionCount, _config.StartTick, startCommand);

			// Step 7, stop recording and playblack
			string stopCommand = "mirv_streams record end; endmovie";
			generated += string.Format(Properties.Resources.execute_command, ++actionCount, _config.EndTick, stopCommand);

			// Step 8, auto close the game if the user want it otherwise stop playback (some ticks after recoding stopped)
			if (_config.AutoCloseGame)
				generated += string.Format(Properties.Resources.execute_command, ++actionCount, _config.EndTick + 128, "quit");
			else
				generated += string.Format(Properties.Resources.stop_playback, ++actionCount, _config.EndTick + 128);

			string content = string.Format(Properties.Resources.main, generated);
			File.WriteAllText(_config.Demo.GetVdmFilePath(), content);
		}

		/// <summary>
		/// Return FFmpeg CLI arguments based on the current configuration.
		/// </summary>
		/// <returns></returns>
		private List<string> GetFFmpegArgs()
		{
			List<string> args = new List<string>();
			args.Add("-y"); // override file if it exist
			args.Add("-f image2");
			args.Add("-framerate " + _config.FrameRate);
			if (!string.IsNullOrEmpty(_config.FFmpegInputParameters))
				args.Add(_config.FFmpegInputParameters);
			args.Add("-i \"" + RawFullPath + "%04d.tga\"");
			args.Add("-i \"" + RawFullPath + ".wav\"");
			args.Add("-vcodec " + _config.VideoCodec);
			args.Add("-qp " + _config.VideoQuality);
			args.Add("-r " + _config.FFmpegVideoFramerate);
			args.Add("-acodec " + _config.AudioCodec);
			args.Add("-b:a " + _config.AudioBitrate + "K");
			if (!string.IsNullOrEmpty(_config.FFmpegExtraParameters))
				args.Add(_config.FFmpegExtraParameters);
			args.Add("\"" + _config.OutputFileDestinationFolder + Path.DirectorySeparatorChar + _config.OutputFilename + ".mp4\"");

			return args;
		}

		/// <summary>
		/// Callback when VirtualDub or FFMpeg is closed.
		/// </summary>
		private void HandleEncodingEnded()
		{
			// delete all RAW files generated by the game and HLAE
			if (_config.CleanUpRawFiles)
			{
				// delete all tga files
				DeleteTgaFiles();
				// delete wav files
				string wavFilePath = GetWavFilePath();
				if (File.Exists(wavFilePath)) File.Delete(wavFilePath);
				// delete the directory created by HLAE
				if (Directory.Exists(RawFullPath)) Directory.Delete(RawFullPath, true);
			}

			// Select the output file in the explorer
			if (_config.OpenInExplorer)
			{
				string filePath = GetOuputFilePath();
				string argument = "/select, \"" + filePath + "\"";
				Process.Start("explorer.exe", argument);
			}
		}

		/// <summary>
		/// Callback when the game is closed.
		/// </summary>
		private async Task HandleGameClosed()
		{
			OnGameClosed?.Invoke();

			// delete VDM file, we don't need it anymore
			string vdmPath = _config.Demo.GetVdmFilePath();
			if (File.Exists(vdmPath)) File.Delete(vdmPath);

			// delete the CFG file, we don't need it anymore
			string cfgPath = GetCfgPath();
			if (File.Exists(cfgPath)) File.Delete(cfgPath);

			// do not continue if TGA file not present, user may have close the game prematurely
			if (!IsFirstTgaExists()) return;

			// generate a video file if the user want it
			if (_config.GenerateVideoFile)
			{
				if (_config.UseVirtualDub)
				{
					// VirtualDub
					GenerateVirtualDubScript();
					ProcessStartInfo psi = new ProcessStartInfo
					{
						Arguments = "/s csgodm.jobs /x",
						FileName = VirtualDubService.GetVirtualDubExePath(),
						WorkingDirectory = VirtualDubService.GetVirtualDubPath(),
					};
					Process p = new Process
					{
						StartInfo = psi,
					};
					p.Start();
					OnVirtualDubStarted?.Invoke();
					await p.WaitForExitAsync();
					OnVirtualDubClosed?.Invoke();
					HandleEncodingEnded();
				}
				else
				{
					// FFmpeg
					List<string> argsList = GetFFmpegArgs();
					string args = string.Join(" ", argsList.ToArray());
					ProcessStartInfo psi = new ProcessStartInfo
					{
						Arguments = args,
						FileName = FFmpegService.GetFFmpegExePath(),
						UseShellExecute = false
					};
					Process p = new Process
					{
						StartInfo = psi,
					};
					OnFFmpegStarted?.Invoke();
					p.Start();
					await p.WaitForExitAsync();
					OnFFmpegClosed?.Invoke();
					HandleEncodingEnded();
				}
			}
		}

		private Task HandleGameStarted()
		{
			return Task.Run(() => OnGameStarted?.Invoke());
		}

		private Task HandleGameRunning()
		{
			return Task.Run(() => OnGameRunning?.Invoke());
		}

		private Task HandleHLAEStarted()
		{
			return Task.Run(() => OnHLAEStarted?.Invoke());
		}

		private Task HandleHLAEClosed()
		{
			return Task.Run(() => OnHLAEClosed?.Invoke());
		}

		private void KillProcess(string processName)
		{
			Process[] currentProcess = Process.GetProcessesByName(processName);
			if (currentProcess.Length > 0) currentProcess[0].Kill();
		}
	}
}
